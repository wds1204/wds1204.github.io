<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    okhttp框架解析 |
    
    modi.wu
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-okhttp框架解析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    okhttp框架解析
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/02/04/okhttp%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2022-02-03T16:25:41.000Z" itemprop="datePublished">2022-02-04</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/android/">android</a> / <a class="article-category-link" href="/categories/okhttp/">okhttp</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>作为Android程序员除了Google官方提供Android源码，开发项目时还要用很多优秀的三方开源库帮助我们快速开发，OKhttp3作为square开源的网络库，已成Android程序员必用的网络库，因为其优秀的代码设计、完善的网络请求功能，也被Google收入官方源码实现。作为开发者学习作为网络的网络有很多分析OkHttp的文章，大多都是讲OkHttp的使用、框架结构以及设计模式等这些内容。而这些只是OkHttp的一些手段和方式，它本质上一个网络请求的库，我们阅读源码的时，实现只不过是为了达到目的一种方式，脱离目的的实现，如缘木求鱼。所以在分析OkHttp源码的时一定要结合http本身的特性，不然就很容易偏离事物本质。</p>
<span id="more"></span>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    <span class="keyword">val</span> socket = Socket(<span class="string">&quot;hencoder.com&quot;</span>, <span class="number">80</span>)</span><br><span class="line">    <span class="keyword">val</span> reader = BufferedReader(InputStreamReader(socket.getInputStream()))</span><br><span class="line">    <span class="keyword">val</span> writer = BufferedWriter(OutputStreamWriter(socket.getOutputStream()))</span><br><span class="line"></span><br><span class="line">    writer.write(<span class="string">&quot;GET / HTTP/1.1\nHost: hencoder.com\n\n&quot;</span>)</span><br><span class="line">    writer.flush()</span><br><span class="line"></span><br><span class="line">    println(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">         <span class="subst">$&#123;reader.readText()&#125;</span></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">          )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是通过Socket实现一个简单的网络连接，而且是非常简陋。有很多内容没有考虑到，比如Http2、SSL、代理、重定向、错误重试等内容。如果把http请求的各种情况都考虑进去，然后自己动手撸个框架，这工作量还是很大。OKHttp就是这样从最底层的网络连接到Http的各种适配，底朝天的完全自己实现了一遍，而且</p>
<p>看源码之前，先从最简单OkHttp的使用开始</p>
<h3 id="OkHttp使用方法简介"><a href="#OkHttp使用方法简介" class="headerlink" title="OkHttp使用方法简介"></a>OkHttp使用方法简介</h3><ol>
<li><p>创建一个OkHttpClient实例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client=OkHttpClient.Builder().build()</span><br></pre></td></tr></table></figure></li>
<li><p>创建Request</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> url = <span class="string">&quot;https://api.github.com/users/wds1204/repos&quot;</span></span><br><span class="line"><span class="keyword">val</span> request: Request = Request.Builder()</span><br><span class="line">          .url(url)</span><br><span class="line">          .build()</span><br></pre></td></tr></table></figure></li>
<li><p>创建Call并发起网络请求</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步请求</span></span><br><span class="line"><span class="keyword">val</span> newCall:Call=client.newCall(request)</span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;okhttp response  <span class="subst">$&#123;response.code&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>分别构建<code>OkHttpClient</code>、<code>Request</code>,然后调用<code>OkHttpClient</code>的<code>newCall</code>,<code>Request</code>作为参数传入，返回一个<code>Call</code>对像。最终调<code>Call</code>的<code>enqueue</code>方法,成功回调<code>onResponse</code>，失败回调<code>onFailure</code>。</p>
</li>
</ol>
<h3 id="OkHttp源码分析"><a href="#OkHttp源码分析" class="headerlink" title="OkHttp源码分析"></a>OkHttp源码分析</h3><blockquote>
<p>okhttp源码版本: 4.9.0</p>
</blockquote>
<p> 在上一小节中介绍了okHttp使用，可以看出整个流程很简而且也容易单上手分。其中<code>OkHttpClient</code>、<code>Request</code>都是通过Build模式构建,一个客户端对象、一个请求的配置，关键点是在<code>newCall</code>方法,进入方法内部：</p>
<blockquote>
<p>OkHttpClient</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>引出RealCall对象。</p>
<h4 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h4><p> newCall返回的RealCall对象，会把此前构建<code>OkHttpClient</code>、<code>Requestcan</code>对象用于创建<code>RealCall</code>,外还有<code>forWebSocket</code>参数，是用来是否支持<code>webSocket</code>协议的，本人对webSocket了解的也不够,感兴趣请自行查阅。接下来会调用<code>RealCall</code>的<code>enqueue</code>这个异步请求方法。</p>
<blockquote>
<p>RealCall</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  callStart()</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分为两个部分：</p>
<ul>
<li>callStart()</li>
<li>client.dispatcher.enqueue(AsyncCall(responseCallback))</li>
</ul>
<p>callStart这个方法是用来触发监听的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">callStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.callStackTrace = Platform.<span class="keyword">get</span>().getStackTraceForCloseable(<span class="string">&quot;response.body().close()&quot;</span>)</span><br><span class="line">  eventListener.callStart(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventListener"><a href="#EventListener" class="headerlink" title="EventListener"></a>EventListener</h4><p>在构建OkHttpClient的时候可以通过eventListener或者eventListenerFactory方法添加EventListener监听。可以用它做http的网络监控，比如dns查询耗时、socket connnect耗时、tls连接耗时、请求发送耗时、响应传输耗时、响应解析耗时。后面遇到此类的就知道是什么涵义了。<br><img src="/../images/okhttp/Eventlistener.png" alt="image.png"><br>​<br><code>client.dispatcher.enqueue(AsyncCall(responseCallback))</code> 调用OkHttpClient中dispatch调度器的enqueue方法。dispatch一看名字就应该想到和线程池相关，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call)<span class="comment">//1把AsyncCall添加到readyAsyncCalls双向队列中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">    <span class="comment">// the same host.</span></span><br><span class="line">    <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">      <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)<span class="comment">//2</span></span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1<code>AsyncCall</code>添加到<code>readyAsyncCalls</code>双向队列中。注射2处找到相应<code>host</code>的<code>AsyncCall</code>，在注射3处会重用上一个<code>AsyncCall</code>的<code>callsPerHost</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>( <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback ) : Runnable &#123;</span><br><span class="line">  <span class="meta">@Volatile</span> <span class="keyword">var</span> callsPerHost = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">reuseCallsPerHostFrom</span><span class="params">(other: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.callsPerHost = other.callsPerHost</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这是什么意思呢，每个异步请求都会放到<code>AsyncCall</code>中，<code>callsPerHost</code>是个<code>AtomicInterger</code>，每次执行<code>promoteAndExecute</code>会调用<code>incrementAndGet</code>，异步任务成功执行后调用<code>decrementAndGet</code>。保持<code>callsPerHost</code>中的Int为0。就是为了标记同一个主机访问的次数。</p>
<p>结合<code>promoteAndExecute</code>方法会看的更清晰：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">    <span class="comment">//maxRequests=64 并发执行的最大请求数</span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">       <span class="comment">//maxRequestsPerHost=4，通过主机的最大请求数并发执行，如果大于等于4就直接continue</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove()</span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      executableCalls.add(asyncCall)<span class="comment">//存放在可执行的集合中</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall)<span class="comment">//存在在runningAsyncCalls双向队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">    <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)<span class="comment">//调用AsyncCall的executeOn,ExecutorService为线程池</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h4><p>每次调用<code>RealCall</code>的<code>enqueue</code>都会创建一个<code>AsyncCall</code>,它是是<code>RealCall</code>的内部类，实现<code>Runnable</code>接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)<span class="comment">//调用execute，最终回调AsyncCall的run方法</span></span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="comment">//发生异常</span></span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调AsyncCall的run方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">        timeout.enter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//拿到响应的response</span></span><br><span class="line">          <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          <span class="comment">//回调responseCallback.onResponse</span></span><br><span class="line">          responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">          cancel()</span><br><span class="line">          <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">            <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">            canceledException.addSuppressed(t)</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> t</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain"></a>getResponseWithInterceptorChain</h4><p>通过<code>getResponseWithInterceptorChain</code>方法拿到这次请求的<code>response</code>，然后回调<code>responseCallback</code>的<code>onResponse</code>，如果失败回调<code>onFailure</code>。这里的<code>responseCallback</code>就是调用<code>RealCall</code>传入来的<code>CallBack</code>。到这里整个网络请求就结束了，是不是感觉就这🤔️Socket的连接呢🤔️TSL连接🤔️报文发送和接收响应🤔️所有的这些东西都包含在<code>getResponseWithInterceptorChain</code>方法中，也就大家说到OkHttp的时候都会提的拦截器模式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">/*======== 1、添加拦截器 ========*/</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	<span class="comment">//1、构建拦截器链RealInterceptorChain</span></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3、开启链式工作</span></span><br><span class="line">      <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>RealInterceptorChain</code>对象，里面包含各种拦截（内置、自定义），然后调用<code>RealInterceptorChain</code>的p<code>roceed</code>方法触发链式工作。<br>​</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">  check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">  calls++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">  <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">  <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="meta-string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">      <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code> val next = copy(index = index + 1, request = request)</code> 把<code>RealInterceptorChain</code>当前<code>interceptors</code>的index前移一位。<br><code>val interceptor = interceptors[index]</code>找到当前的interceptor，然后调用<code>interceptor</code>的<code>intercept</code>方法处具体的拦截器方法。刚触发链表工作时，如果有没添加自定义拦截器到<code>interceptors</code>的,第一个运行拦截器就是<code>RetryAndFollowUpInterceptor</code>。</p>
<blockquote>
<p>RetryAndFollowUpInterceptor</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">//...      </span></span><br><span class="line">      response = realChain.proceed(request)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RetryAndFollowUpInterceptor</code>的<code>intercept</code>方法内又会调用<code>RealInterceptorChain</code>的<code>proceed</code>方法。此时<code>RealInterceptorChain</code>中的<code>interceptors</code>的index已经往前移了一位，所以会执行下一个拦截器，最后一直执行到最后一个拦截器，然后以往前传递当前拦截器的``response`<br>之所以把OkHttp的拦截器设计成三个步骤：触发前段、触发拦截器、触发后段。应该是考虑到网络请求的特性，我们通过需要在请求前和请求后分别做一些干预操作，这样设计便于处理。下面给出一张拦截器流程图:</p>
<p><img src="/../images/okhttp/interceptor.png" alt="interceptor.png"></p>
<h3 id="OKHttp配置简介"><a href="#OKHttp配置简介" class="headerlink" title="OKHttp配置简介"></a>OKHttp配置简介</h3><p>补充一下<code>OKHttpClient</code>相关内容，它相当于配置中心，所有的请求都会共享这些配置(例如出错是否重拾、共享的连接池)。<code>OkHttpClient</code>中配置主要有：</p>
<ul>
<li><code>dispatcher: Dispatcher</code>:调用器，用于调度后台发起的网路请求，有后台总请求数和单主机总请求数的控制。</li>
<li><code>protocols: List&lt;Protocol&gt;</code>: 支持的应用层协议，即HTTP/1.1、HTTP/2等。</li>
<li><code>connectionSpecs: List&lt;ConnectionSpec&gt;</code>: 应用层支持的Socket设置，即使用明文传输(HTTP)，还是某个版本的TLS(HTTPS)</li>
<li><code>interceptors: List&lt;Interceptor&gt;</code>:拦截器，大多数时候使用的 Interceptor 都应该配置到这里。</li>
<li><code>networkInterceptors: List&lt;Interceptor&gt;</code>:直接和网络请求交互的 Interceptor 配置到这里，例如如果你想查看返回的 301报文或者未解压的<code>Response Body</code>，需要在这里看。</li>
<li><code>cookieJar: CookieJar</code>:管理Cookie的控制器，OkHttp提供了对<code>Cookie</code>存取的支持,但没有给出具体的存取实现，默认是个<code>NO_COOKIES</code>,如果需要存取 Cookie，你得自己完成实现。</li>
<li><code>cache: Cache</code>:Cache的默认的配置也是没有的，如果需要需自己配置Cache存储文件的位置、存储空间的上线以及缓存策略。</li>
<li><code>hostnameVerifier: HostnameVerifier</code>:用于验证HTTPS握手过程下载的证书所属者是否和自己要访问的主机域名是否一致。</li>
<li><code>hostnameVerifier: HostnameVerifier</code> :用于验证 HTTPS 握手过程 中下载到的证书所属者是否和自己要访问的主机名一致。</li>
<li><code>certificatePinner: CertificatePinner</code> :用于设置 HTTPS 握手 过程中针对某个 Host 额外的的 Certificate Public Key Pinner，即把网站证 书链中的每一个证书公钥直接拿来提前配置进 OkHttpClient 里去，作为正 常的证书验证机制之外的一次额外验证。</li>
<li><code>authenticator: Authenticator</code> :用于自动重新认证。配置之后，在 请求收到 401 状态码的响应是，会直接调用 authenticator ，手动加 入 Authorization header 之后自动重新发起请求。</li>
<li><code>followRedirects: boolean</code> :遇到重定向的要求是，是否自动 follow。</li>
<li><code>followSslRedirects: boolean</code>: 在重定向时，如果原先请求的是http而重定向的目标是https，或者原先请求的是 https 而重定向的目标是 http，是否依然自动 follow。(记得，不是「是否自动 follow HTTPS URL重定向的意思，而是是否自动 follow 在 HTTP 和 HTTPS 之间切换的重定 向)</li>
<li><code>retryOnConnectionFailure: boolean</code>:在请求失败的时候是否自动重试。注意，大多数的请求失败并不属于 OkHttp 所定义的「需要重试」，这种重试只适用于「同一个域名的多个 IP 切换重试」「Socket 失效重试」等情况。</li>
<li><code>connectTimeoutMillis:Int</code> :建立连接(TCP 或 TLS)的超时时间。</li>
<li><code>readTimeoutMillis:Int</code> :发起请求到读到响应数据的超时时间。</li>
<li><code>writeTimeoutMillis :Int</code> :发起请求并被目标服务器接受的超时时间。(为什么?因为有时候对方服务器可能由于某种原因而不读取你的 Request) newCall(Request) 方法会返回一个<code>RealCall</code>对象，它是Call接口</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wds1204.github.io/2022/02/04/okhttp%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" data-id="clqp75lbq001xievhbk9rgn2d" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/okhttp/" rel="tag">okhttp</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/02/10/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BRetryAndFollowUpInterceptor/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      okhttp拦截器之RetryAndFollowUpInterceptor
      
    </div>
  </a>
  
  
  <a href="/2022/02/03/HTTPS/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">HTTPS</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>modi.wu &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank">WU</a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="modi.wu"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>