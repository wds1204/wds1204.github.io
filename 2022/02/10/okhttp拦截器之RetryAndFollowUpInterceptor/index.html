<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    okhttp拦截器之RetryAndFollowUpInterceptor |
    
    modi.wu
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-okhttp拦截器之RetryAndFollowUpInterceptor" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  okhttp拦截器之RetryAndFollowUpInterceptor
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/02/10/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BRetryAndFollowUpInterceptor/" class="article-date">
  <time datetime="2022-02-10T15:38:39.000Z" itemprop="datePublished">2022-02-10</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/android/">android</a> / <a class="article-category-link" href="/categories/okhttp/">okhttp</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <blockquote>
<p>okhttp源码版本: 4.9.0</p>
</blockquote>
<p>承接上篇<a href="https://wds1204.github.io/2022/02/04/okhttp%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">okhttp框架解析</a></p>
<p>第一个内置拦截器，<code>RetryAndFollowUpInterceptor</code>如它的名字所诉重试&amp;重定向。它会对特定的网络错误类型和需要重定向的请求进行请求网络重试，那么要想做到重试估计要开启一个循环不停的处理，那它具体是如何工作的呢?<span id="more"></span></p>
<p>先上<code>RetryAndFollowUpInterceptor:intercept</code>方法代码：</p>
<blockquote>
<p>RetryAndFollowUpInterceptor:intercept</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//开启轮询</span></span><br><span class="line"> <span class="comment">//1、构建一个ExchangeFinder</span></span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2、运行下一个把拦截器，并拿到请求响应结果</span></span><br><span class="line">        response = realChain.proceed(request)<span class="comment">//拿到响应结果</span></span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">          <span class="comment">//3 判断发生的RouteException是否回复</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;<span class="comment">//</span></span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span><span class="comment">//再次轮询</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">         <span class="comment">//4 判断发生的IOException是否回复</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span><span class="comment">//再次轮询</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="comment">//5 根据上一次的Response，构建一个新的response</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;<span class="comment">//之前的Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="comment">//6、根据响应码创建一个新的Request请求  </span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)<span class="comment">//重定向</span></span><br><span class="line"><span class="comment">//7、上一步构建的Request为空，则不再继续下去，直接把的Response返回</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//8. 如果构建的Request的body为一次性的请求，也同样直接返回Response</span></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line"><span class="comment">//9、如果重定向次数大于20次，也直接抛出异常，否次进入下次轮询也就是重试</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，在关键流程都做了注释。可以看<code>intercept</code>方法内部直接开启了一个while循环，和预期的一样。循环内部可以主要分为三块：</p>
<ol>
<li>网络请求前的准备工作</li>
<li>把责任链往下传，运行下一个拦截器</li>
<li>根据响应结果判断是否要重试</li>
</ol>
<h4 id="第一步：网络请求前的准备工作："><a href="#第一步：网络请求前的准备工作：" class="headerlink" title="第一步：网络请求前的准备工作："></a>第一步：网络请求前的准备工作：</h4><p>​</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//开启轮询</span></span><br><span class="line"> <span class="comment">//1、构建一个ExchangeFinder</span></span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)<span class="comment">//</span></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>调用<code>RealCall</code>的<code>enterNetworkInterceptorExchange</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">enterNetworkInterceptorExchange</span><span class="params">(request: <span class="type">Request</span>, newExchangeFinder: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">  check(interceptorScopedExchange == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (newExchangeFinder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.exchangeFinder = ExchangeFinder(</span><br><span class="line">        connectionPool,</span><br><span class="line">        createAddress(request.url),</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里会给<code>RealCall</code>创建一个<code>ExchangeFinder</code>对象,这个<code>ExchangeFinder</code>的构造函数中包含两个重要对象<code>connectionPool</code>和<code>Address</code>。<code>connectionPool</code>连接池在之后<code>ConnectInterceptor</code>拦截器中会重点讲到，<code>Address</code>的创建通过<code>createAddress</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createAddress</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: Address &#123;</span><br><span class="line">   <span class="keyword">var</span> sslSocketFactory: SSLSocketFactory? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">var</span> hostnameVerifier: HostnameVerifier? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">var</span> certificatePinner: CertificatePinner? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">if</span> (url.isHttps) &#123;</span><br><span class="line">     sslSocketFactory = client.sslSocketFactory</span><br><span class="line">     hostnameVerifier = client.hostnameVerifier</span><br><span class="line">     certificatePinner = client.certificatePinner</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> Address(</span><br><span class="line">       uriHost = url.host,<span class="comment">//主机名</span></span><br><span class="line">       uriPort = url.port,<span class="comment">//端口号</span></span><br><span class="line">       dns = client.dns,<span class="comment">//dns</span></span><br><span class="line">       socketFactory = client.socketFactory,<span class="comment">// socket工厂</span></span><br><span class="line">       sslSocketFactory = sslSocketFactory,<span class="comment">//TLS</span></span><br><span class="line">       hostnameVerifier = hostnameVerifier,<span class="comment">//TLS 主机验证</span></span><br><span class="line">       certificatePinner = certificatePinner,<span class="comment">//证书hash</span></span><br><span class="line">       proxyAuthenticator = client.proxyAuthenticator,<span class="comment">//身份验证</span></span><br><span class="line">       proxy = client.proxy,<span class="comment">//代理</span></span><br><span class="line">       protocols = client.protocols,<span class="comment">//协议类型：HTTP_1_1、HTTP_2</span></span><br><span class="line">       connectionSpecs = client.connectionSpecs,<span class="comment">//连接规则：加密和不加密</span></span><br><span class="line">       proxySelector = client.proxySelector</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>createAddress</code>创建<code>Address</code>对象，其包含主机名、端口号、TSL等建立网络联系相关的内容、Authenticator、代理、协议等，<code>Address</code>又用于<code>ExchangeFinder</code>对象的创建。<code>ExchangeFinder</code>从字面含义解释为交换查找器，一次网络请求和响应作为一次数据交换，所以<code>ExchangeFinder</code>是作为一个发现数据交换的工具，也为建立网络连接做好前置的准备。</p>
<h4 id="第二步：把责任链往下传"><a href="#第二步：把责任链往下传" class="headerlink" title="第二步：把责任链往下传"></a>第二步：把责任链往下传</h4><p>这里比简单：<code>response = realChain.proceed(request)</code>拿到<code>response</code></p>
<h4 id="第三部：判断是否重试-amp-重定向"><a href="#第三部：判断是否重试-amp-重定向" class="headerlink" title="第三部：判断是否重试&amp;重定向"></a>第三部：判断是否重试&amp;重定向</h4><p>先看<code>catch</code>部分地内容:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//开启轮询</span></span><br><span class="line"> <span class="comment">//1、构建一个ExchangeFinder</span></span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2、运行下一个把拦截器，并拿到请求响应结果</span></span><br><span class="line">        response = realChain.proceed(request)<span class="comment">//拿到响应结果</span></span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">          <span class="comment">//3 判断发生的RouteException是否回复</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;<span class="comment">//</span></span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span><span class="comment">//再次轮询</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">         <span class="comment">//4 判断发生的IOException是否回复</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">continue</span><span class="comment">//再次轮询</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发生的异常是属于<code>RouteException</code>或者<code>IOException</code>,并且是可恢复的请求，则continue再次发生网络请求。<br>那我们先分析一下<code>RouteException</code>情况：</p>
<blockquote>
<p>RealCall</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  e: <span class="type">IOException</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  call: <span class="type">RealCall</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  userRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  requestSendStarted: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 This exception is fatal</span></span><br><span class="line">  <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4 No more routes to attempt.</span></span><br><span class="line">  <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>如果<code>OkHttpClient</code>在构建时设置<code>retryOnConnectionFailure</code>为false，则不重试，默认为true</li>
<li>如果请求最多只能被发送一次，则不会重试</li>
<li>如果是以下致命的错误不重试<ol>
<li>ProtocolException协议异常</li>
<li>SocketTimeoutException Socket连接超时异常</li>
<li>SSLHandshakeException&amp;&amp;CertificateException TSL握手异常</li>
<li>SSLPeerUnverifiedException 异常</li>
</ol>
</li>
<li>如果寻找到可用的路由，如果不存在也不允许重试</li>
</ol>
<p>在第四个条件中什么叫可用路由呢？ 需要先复习一下http相关的知识，访问某个确定的主机需要满足三个地址：IP地址、端口号、代理类型。比如 you个域名叫<code>http://wds.com</code>，一个域名可能有多个IP，如果给这个设置了http代理，就存在如下几种情况；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http://wds.com </span><br><span class="line">1:ip:1.2.3.4</span><br><span class="line">  port:80</span><br><span class="line"></span><br><span class="line">2:ip:5.6.7.8</span><br><span class="line">  port:80</span><br><span class="line"></span><br><span class="line">假设代理的域名叫http://wdsproxy.com proxy：http</span><br><span class="line"></span><br><span class="line">1:ip:11.22.33.44</span><br><span class="line">  port:80</span><br><span class="line"></span><br><span class="line">2:ip:55.66.77.88</span><br><span class="line">  port:80</span><br><span class="line">代理和不代理共就四中路由情况 </span><br></pre></td></tr></table></figure>
<p>再回到代码中，看<code>Route</code>这个类<br><img src="/../images/okhttp/Route.png" alt="router"><br>Route包含：Address（包含端口号）、代理类型、IP地址。所以<code>retryAfterFailure</code>方法就是从RrouteSelection中遍历<br>代码如下很简单可自行阅读：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">retryAfterFailure</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (refusedStreamCount == <span class="number">0</span> &amp;&amp; connectionShutdownCount == <span class="number">0</span> &amp;&amp; otherFailureCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// Nothing to recover from.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> retryRoute = retryRoute()</span><br><span class="line">  <span class="keyword">if</span> (retryRoute != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Lock in the route because retryRoute() is racy and we don&#x27;t want to call it twice.</span></span><br><span class="line">    nextRouteToTry = retryRoute</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have a routes left, use &#x27;em.</span></span><br><span class="line">  <span class="keyword">if</span> (routeSelection?.hasNext() == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we haven&#x27;t initialized the route selector yet, assume it&#x27;ll have at least one route.</span></span><br><span class="line">  <span class="keyword">val</span> localRouteSelector = routeSelector ?: <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we do have a route selector, use its routes.</span></span><br><span class="line">  <span class="keyword">return</span> localRouteSelector.hasNext()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析完<code>RouteException</code>，<code>IOException</code>情况类似，这里就不分析了。</p>
<p>followUpRequest方法:<br>根据请求码创建一个新的请求，以供下一次重试请求使用：会根据上一次的请求结果添加认证头信息，跟踪重定向或处理客户端请求超时等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Request? &#123;</span><br><span class="line">  <span class="keyword">val</span> route = exchange?.connection?.route()</span><br><span class="line">  <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">  <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">    HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">      <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line"></span><br><span class="line">    HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">      <span class="comment">// 408&#x27;s are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">      <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">      <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">      <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">        <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">      <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">        <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> userResponse.request</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">        <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">        <span class="keyword">return</span> userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HTTP_MISDIRECTED_REQUEST -&gt; &#123;</span><br><span class="line">      <span class="comment">// OkHttp can coalesce HTTP/2 connections even if the domain names are different. See</span></span><br><span class="line">      <span class="comment">// RealConnection.isEligible(). If we attempted this and the server returned HTTP 421, then</span></span><br><span class="line">      <span class="comment">// we can retry on a different connection.</span></span><br><span class="line">      <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">      <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (exchange == <span class="literal">null</span> || !exchange.isCoalescedConnection) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      exchange.connection.noCoalescedConnections()</span><br><span class="line">      <span class="keyword">return</span> userResponse.request</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>HTTP_PROXY_AUTH（407）：代理认证，需要进行代理认证（默认实现返回null，可以进行重写覆盖实现）；</li>
<li>HTTP_UNAUTHORIZED（401）：未授权，需要进行授权认证（默认实现返回null，可以进行重写覆盖实现）；</li>
<li>HTTP_PERM_REDIRECT（307） 或者 HTTP_TEMP_REDIRECT（308） ：临时重定向或者永久重定向，如果请求方法不为GET且不为METHOD，返回空，表示不允许重定向；</li>
<li>HTTP_MULT_CHOICE（300） 多选项</li>
<li>HTTP_MOVED_PERM（301） 永久重定向，表示请求的资源已经分配了新的URI，以后应该使用新的URI 、</li>
<li> HTTP_MOVED_TEMP（302）临时性重定向</li>
<li> HTTP_MOVED_TEMP（303）表示由于请求对应的资源存在着另外一个URI，应该使用GET方法定向获取请求的资源</li>
<li> HTTP_CLIENT_TIMEOUT(408）：请求超时，</li>
<li> HTTP_UNAVAILABLE（503）：表明服务器暂时处于超负载或正在进行停机维护，现无法处理请求。</li>
<li>本次请求结果和上一次请求结果均返回503，则放弃重试</li>
<li>如果返回的Retry-After为0，没有任何延迟，则返回Request对象，否则返回空;</li>
</ol>
<p><code>RetryAndFollowUpInterceptor</code>主要内容就分析完了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wds1204.github.io/2022/02/10/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BRetryAndFollowUpInterceptor/" data-id="cl95pbrdy0013k4vh43syfbh9" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/okhttp/" rel="tag">okhttp</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/02/12/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BBridgeInterceptor/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      okhttp拦截器之BridgeInterceptor
      
    </div>
  </a>
  
  
  <a href="/2022/02/04/okhttp%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">okhttp框架解析</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>modi.wu &copy; 2022</li>
      
        <li>WU</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="modi.wu"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>