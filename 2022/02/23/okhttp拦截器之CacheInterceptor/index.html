<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    okhttp拦截器之CacheInterceptor |
    
    modi.wu
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-okhttp拦截器之CacheInterceptor" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  okhttp拦截器之CacheInterceptor
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/02/23/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BCacheInterceptor/" class="article-date">
  <time datetime="2022-02-23T14:49:02.000Z" itemprop="datePublished">2022-02-23</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/android/">android</a> / <a class="article-category-link" href="/categories/okhttp/">okhttp</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p><code>CacheInterceptor</code>拦截器官方给个注释：Serves requests from the cache and writes responses to the cache.用于从缓存中获取相应和把相应写入缓存中，<code>okhttp</code>缓存默认是不开启,需要通过如下方式设置<code>Cache</code>。</p>
<span id="more"></span>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">        .cache(</span><br><span class="line">            Cache(</span><br><span class="line">                directory = File(application.cacheDir, <span class="string">&quot;http_cache&quot;</span>),</span><br><span class="line">                maxSize = <span class="number">50L</span> * <span class="number">1024L</span> * <span class="number">1024L</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<p>配置完<code>HttpClient</code>网络缓存后，这样就有了缓存的效果,但也可以说没有效果。因为如果你想在网络断开的情况下再次请求网络后加载缓存的内容,如果只有这么设置可能不够，可能需要再request中加入CacheControl.FORCE_CACHE这个策略。代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">            .cache(</span><br><span class="line">                Cache(</span><br><span class="line">                    directory = File(application.cacheDir, <span class="string">&quot;http_cache&quot;</span>),</span><br><span class="line">                    maxSize = <span class="number">50L</span> * <span class="number">1024L</span> * <span class="number">1024L</span></span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            .addInterceptor(Interceptor &#123; chain -&gt;</span><br><span class="line">                <span class="keyword">var</span> requestBuild = chain.request().newBuilder()</span><br><span class="line">                <span class="keyword">if</span> (NetworkInfoUtils.isNetConnection(application)) &#123;</span><br><span class="line">                    requestBuild.cacheControl(CacheControl.FORCE_CACHE)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                chain.proceed(requestBuild.build())</span><br><span class="line">            &#125;)</span><br><span class="line">            .build()</span><br></pre></td></tr></table></figure>
<p>通常情况下是自定一个拦截器，判断本地网络断开情况给<code>Request</code>添加<code>CacheControl.FORCE_CACHE</code>,不影响正常网络的情况。<br>至于为什么，先看拦截器源码：</p>
<!--more-->

<blockquote>
<p>okhttp源码版本: 4.9.0</p>
</blockquote>
<h3 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h3><p>进入<code>CacheInterceptor</code>拦截器<code>intercept</code>方法的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    <span class="comment">//1、如果HttpClient设置cache，则会通过此cache的get方法：传入当前request，获取一个候选缓存——&gt;response</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line">    <span class="comment">//2、获取当前系统时间</span></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line">    <span class="comment">//3、根据CacheStrategy的工厂Factory，构造一个一个CacheStrategy对象，可以看出是通过传入时间、request、cacheCandidate计算一个缓存策略工厂.</span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="comment">//4、取出networkRequest（当前的网络请求）、cacheResponse（缓存）</span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line">    <span class="comment">//5、对相应进行跟踪计数</span></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line">    <span class="comment">//6、如果之前还候选缓存不为空，但通过计算处理后cacheResponse为空，那么就关闭候选缓存的资源</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7、如果要发送的请求为空&amp;也没有缓存，那么直接返回504给客户端，并且body为空</span></span><br><span class="line">    <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build().also &#123;</span><br><span class="line">          listener.satisfactionFailure(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//8、如果不需要发送网络请求，那么直接缓存返回给客户端</span></span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7、缓存命中的监听</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8、此时没有可用缓存，继续调用链的下一步，在这里就是发起真正的网络请求</span></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//10、在网络请求完成后，如果已经有了一个缓存，需要做一些其他条件的判断</span></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//11、如果响应码是304，表面未改变，说明无需再次传输请求的内容，那就把缓存返回给客户端</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//12、如果以上的条件都不成立，生成最终的response</span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line">    <span class="comment">//13、如果cache没有设置，response合法并且判断是可缓存，则调用cache的put方法存储响应</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//14、对于一些的请求方法:POST、PATCH、PUT、DELETE、MOVE不支持，把缓存移除</span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中的注释已经说明了<code>CacheInterceptor</code>大致的工作流程，逻辑很简单就是从cache中获取<code>cacheCandidate</code>候选缓存，然后构造出一个<code>CacheStrategy</code>策略对象。其中<code>CacheStrategy</code>会包含两个重要的<code>networkRequest</code>（当前的网络请求）、<code>cacheResponse</code>（缓存）对象，然后根据这两个对象与否来判断缓存情况。</p>
<h4 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1-Cache"></a>1.1-Cache</h4><p>Cache的get获取缓存，用到的是DiskLruCache，key是通过MD5处理后的url，所以这里只适用于GET方法请求,在put保存缓存的时候也对非GET方法进行了过滤。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response? &#123;</span><br><span class="line">  <span class="keyword">val</span> key = key(request.url)</span><br><span class="line">  <span class="keyword">val</span> snapshot: DiskLruCache.Snapshot = <span class="keyword">try</span> &#123;</span><br><span class="line">    cache[key] ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Give up because the cache cannot be read.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> entry: Entry = <span class="keyword">try</span> &#123;</span><br><span class="line">    Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">    snapshot.closeQuietly()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> response = entry.response(snapshot)</span><br><span class="line">  <span class="keyword">if</span> (!entry.matches(request, response)) &#123;</span><br><span class="line">    response.body?.closeQuietly()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-CacheStrategy"><a href="#1-2-CacheStrategy" class="headerlink" title="1.2-CacheStrategy"></a>1.2-CacheStrategy</h4><p>从上面的流程可知，主要逻辑就是<code>CacheStrategy</code>策略对象的构建，先是又一个Factory工厂</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> nowMillis: <span class="built_in">Long</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> cacheResponse: Response?</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sentRequestMillis = cacheResponse.sentRequestAtMillis</span><br><span class="line">      <span class="keyword">this</span>.receivedResponseMillis = cacheResponse.receivedResponseAtMillis</span><br><span class="line">      <span class="keyword">val</span> headers = cacheResponse.headers</span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until headers.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> fieldName = headers.name(i)</span><br><span class="line">        <span class="keyword">val</span> value = headers.value(i)</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">          fieldName.equals(<span class="string">&quot;Date&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            servedDate = value.toHttpDateOrNull()</span><br><span class="line">            servedDateString = value</span><br><span class="line">          &#125;</span><br><span class="line">          fieldName.equals(<span class="string">&quot;Expires&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            expires = value.toHttpDateOrNull()</span><br><span class="line">          &#125;</span><br><span class="line">          fieldName.equals(<span class="string">&quot;Last-Modified&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            lastModified = value.toHttpDateOrNull()</span><br><span class="line">            lastModifiedString = value</span><br><span class="line">          &#125;</span><br><span class="line">          fieldName.equals(<span class="string">&quot;ETag&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            etag = value</span><br><span class="line">          &#125;</span><br><span class="line">          fieldName.equals(<span class="string">&quot;Age&quot;</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">            ageSeconds = value.toNonNegativeInt(-<span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会在<code>init</code>函数涉及到的header说明：</p>
<table>
<thead>
<tr>
<th>header</th>
<th>说明</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td></td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td></td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td></td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</a></td>
</tr>
<tr>
<td>Age</td>
<td>一个非负整数，表示对象在缓存代理服务器中存贮的时长，以秒为单位。</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age</a></td>
</tr>
</tbody></table>
<p><code>CacheStrategy</code>#<code>Factory</code># <code>compute</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun compute(): CacheStrategy &#123;</span><br><span class="line">  val candidate = computeCandidate()</span><br><span class="line"></span><br><span class="line">  // We&#x27;re forbidden from using the network and the cache is insufficient.</span><br><span class="line">  if (candidate.networkRequest != null &amp;&amp; request.cacheControl.onlyIfCached) &#123;</span><br><span class="line">    return CacheStrategy(null, null)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return candidate</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先不看<code>computeCandidate</code>,注意下面有个禁止网络和内存不足的时候，会返回一个<code>CacheStrategy(null, null)</code>,这种情直接对于<code>CacheInterceptor</code>中注释7的情况：返回一个响应码504,body为空response。</p>
<p>重点看<code>computeCandidate</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeCandidate</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">    <span class="comment">//1、如果cacheResponse为空，那肯定没有缓存数据，直接返回只有request的CacheStrategy</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、如果是https请求，并且没有TSL握手，那自然没有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps &amp;&amp; cacheResponse.handshake == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//3、判断cacheResponse是否是可缓存，如果cacheResponse是不符合规则的，自然也不需要。</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//4、如果配置了不缓存或者request headers中包含If-Modified-Since或者If-None-Match</span></span><br><span class="line">    <span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"> <span class="comment">//5、获取缓存的age</span></span><br><span class="line">    <span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line">    <span class="comment">//6、从服务日期开始，返回响应最新事件</span></span><br><span class="line">    <span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line"> <span class="comment">//7、和缓存最大age比较</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">      freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//8、表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</span></span><br><span class="line">    <span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">      minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//9、表示响应不能已经过时超过该给定的时间。</span></span><br><span class="line">    <span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">      maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">      <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">      <span class="comment">//提示服务器提供的响应已过期</span></span><br><span class="line">      <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">        builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//如果缓存服务器采用启发式方法，将缓存的有效期设置为24小时，而该响应时间超过24小时则触发该提示</span></span><br><span class="line">      <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">      <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">        builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//10、返回一个不需要请求带缓存的CacheStrategy</span></span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注释11 构造一个需要请求和缓存的CacheStrategy</span></span><br><span class="line">    <span class="comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span></span><br><span class="line">    <span class="comment">// will not be transmitted.</span></span><br><span class="line">    <span class="keyword">val</span> conditionName: String</span><br><span class="line">    <span class="keyword">val</span> conditionValue: String?</span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">      etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">        conditionValue = etag</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">        conditionValue = lastModifiedString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">        conditionValue = servedDateString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>) <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conditionalRequestHeaders = request.headers.newBuilder()</span><br><span class="line">    conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conditionalRequest = request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">return</span> CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注释3：调用<code>isCacheable</code>方法判断是否可缓存，但是其实在保存缓存时,也会调用<code>isCacheable</code>方法判断<code>response</code>符合与否规则才保存,所以理论上并不会触发这个条件，感觉是个多余的判断。而官方注释中给解释也说，如果正常保存数据的话这个判断是冗余的。<blockquote>
<p>If this response shouldn’t have been stored, it should never be used as a response source.<br>This check should be redundant as long as the persistence store is well-behaved and the rules are constant.</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>注释4:如果配置了不使用缓存这个很好理解，至于它另一个条件，可查看两个header：If-Modified-Since、If-None-Match</p>
<ul>
<li>If-Modified-Since ： 是一个条件式请求首部，服务器只有在请求的资源在给定的日期时间之后对内容进行修改的情况下才会将资源返回，状态码为200.如果请求的资源从那时起未经修改，那么返回一个不带主体消息的304，而在Last_Modified 首部中会带有上一次修改时间。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a></li>
</ul>
<ul>
<li>if-None-Match:是一个条件式请求首部，对于GET和HEAD请求方法来说，当且仅当服务器上没有任何资源的ETAG属性值与这个首部中列出的相匹配的实际，服务器才会返回请求的资源，响应码为200，对于其他方法来说，当且仅当最终确认没有已存在的资源的ETAG属性中所列出的相匹配的时候，才会对请求进行相应的处理。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">if-None-Match</a></li>
</ul>
</li>
</ul>
<ul>
<li>注释5～10:都是与<code>Cache-Control</code>这个header相关，</li>
</ul>
<table>
<thead>
<tr>
<th>Cache-Control</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max-age=<seconds></td>
<td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td>
</tr>
<tr>
<td>s-maxage=<seconds></td>
<td>覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</td>
</tr>
<tr>
<td>max-stale [=&lt;seconds&gt;]</td>
<td>表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</td>
</tr>
<tr>
<td>min-fresh=<seconds></td>
<td>表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</td>
</tr>
</tbody></table>
<p><code>Cache-Control</code>通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。<br>主要是这段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回一个不需要请求且带缓存的CacheStrategy</span></span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>如果获取到的缓存<code>response</code>中的<code>Cache-Control</code>的<code>no-cache</code>为false，<code>ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis</code>这段代码不知道怎么表达，可以简单的理解为缓存中的响应对应的时间没有过期。<br>而且如果你们的服务器响应是按照标准<code>Cache-Control</code>方式的设置缓存，其实客户端不需要做任何改动，使用Okhttp完全可以达到我们想要的效果。但实际情况是很多服务端也不清楚http现有的这套机制，要想实现这套机制要么你推动服务端的同学其配合实现。好在<code>OkHttp</code>也很人性的做了支持，正如文章开头的时候可以设置<code>CacheControl.FORCE_CACHE</code>。它的作用是个就是给<code>maxStaleMillis</code>设置了一个无情大的数，导致条件一直成立。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> FORCE_CACHE = Builder()</span><br><span class="line">       .onlyIfCached()</span><br><span class="line">       .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)</span><br><span class="line">       .build()</span><br></pre></td></tr></table></figure>

<ul>
<li>注释11后面一大段会构造一个<code>nerworkRequest</code>、<code>cacheResponse</code>不为空的<code>CacheStrategy</code>.</li>
</ul>
<p><code>CacheStrategy</code>构造对象生成分析完了，再次回头看<code>CacheInterceptor</code>拦截器中的方法一些就很清晰了。</p>
<p>最后总结一下：<code>CacheInterceptor</code>这个拦截器用来处理缓存效果，如果前后端正确理解Http协议中关于<code>Cahce-Control</code>的约定，那就是标准的流程，无需做额外不必要的工作，<code>OkHttp</code>已经帮我门处理一切关于流程的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wds1204.github.io/2022/02/23/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BCacheInterceptor/" data-id="cl95pbrdw0011k4vh2mwg2a3k" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/okhttp/" rel="tag">okhttp</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/02/28/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BConnectInterceptor/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      okhttp拦截器之ConnectInterceptor
      
    </div>
  </a>
  
  
  <a href="/2022/02/12/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BBridgeInterceptor/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">okhttp拦截器之BridgeInterceptor</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>modi.wu &copy; 2022</li>
      
        <li>WU</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="modi.wu"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>