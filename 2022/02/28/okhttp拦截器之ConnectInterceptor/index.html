<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    okhttp拦截器之ConnectInterceptor |
    
    modi.wu
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-okhttp拦截器之ConnectInterceptor" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    okhttp拦截器之ConnectInterceptor
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/02/28/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BConnectInterceptor/" class="article-date">
  <time datetime="2022-02-28T13:27:59.000Z" itemprop="datePublished">2022-02-28</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/android/">android</a> / <a class="article-category-link" href="/categories/okhttp/">okhttp</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <!--  -->
<span id="more"></span>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>之前讲到的拦截器都是一些关于响应前和响应后的处理，并没触及到网络连接的核心。比如DNS解析、TCL连接、TSL握手、连接池复用等。这些内容都在这次讲到的<code>ConnectInterceptor</code>拦截器中，既然这么重要那就到源码中一探究竟吧：</p>
<h3 id="ConnectInterceptor-interce"><a href="#ConnectInterceptor-interce" class="headerlink" title="ConnectInterceptor::interce"></a>ConnectInterceptor::interce</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ConnectInterceptor : Interceptor &#123;</span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">    <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">    <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该拦截器的主要作用：打开一个目标服务器连接，然后将这个请求叫个下一个拦截其处理。这个连接其实就是TCP连接，用于网络请求的请求和响应。</p>
<h2 id="如何获取连接"><a href="#如何获取连接" class="headerlink" title="如何获取连接"></a>如何获取连接</h2><p>拦截器中的关键代码就是调用<code>RealCall</code>的<code>initExchange</code>方法，它会返回一个<code>Exchange</code>对象。从字面含义<code>Exchange</code>是交换的意思，在这里把一次网络请求和响应当作一次数据交换。</p>
<h3 id="RealCall-initExchange"><a href="#RealCall-initExchange" class="headerlink" title="RealCall::initExchange"></a>RealCall::initExchange</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Finds a new or pooled connection to carry a forthcoming request and response. */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(expectMoreExchanges) &#123; <span class="string">&quot;released&quot;</span> &#125;</span><br><span class="line">      check(!responseBodyOpen)</span><br><span class="line">      check(!requestBodyOpen)</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">val</span> exchangeFinder = <span class="keyword">this</span>.exchangeFinder!!</span><br><span class="line">     <span class="comment">//找到一个ExchangeCode</span></span><br><span class="line">    <span class="keyword">val</span> codec = exchangeFinder.find(client, chain)</span><br><span class="line">    <span class="comment">//把ExchangeCode用于构造一个Exchange</span></span><br><span class="line">    <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder, codec)</span><br><span class="line">    <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line">    <span class="keyword">this</span>.exchange = result</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.requestBodyOpen = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>.responseBodyOpen = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    <span class="comment">//返回创建的Exchagne对象</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意该放的注释：找到一个新的或者连接池中一个健康可用的连接，用于即将到来了请求和响应。那很明显<code>ExchangeFinder.find</code>方法创建或重用连接池的逻辑都在这里面。先不急看该方法。解释下刚出现的两个类：<code>ExchangeCode</code>、<code>Exchange</code>，先看他们类注释：</p>
<h4 id="ExchangeCodec"><a href="#ExchangeCodec" class="headerlink" title="ExchangeCodec"></a>ExchangeCodec</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Encodes HTTP requests and decodes HTTP responses. */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ExchangeCodec</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个接口，<code>ExchangeCodec</code>应是<code>ExchangeCodeDecode</code>缩写，用于对<code>HTTP</code>请求的编码和响应的解码。具体的实现类有两个，分别是<code>Http1ExchangeCodec</code>和<code>Http2ExchangeCodec</code>。拥有的能力如下图：<br><img src="/./../images/okhttp/image1.png" alt="image.png"><br>挑一个<code>Http1ExchangeCodec</code>的<code>writeRequestHeaders</code>看看具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeRequestHeaders</span><span class="params">(request: <span class="type">Request</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestLine = RequestLine.<span class="keyword">get</span>(request, connection.route().proxy.type())</span><br><span class="line">  writeRequest(request.headers, requestLine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeRequest</span><span class="params">(headers: <span class="type">Headers</span>, requestLine: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  check(state == STATE_IDLE) &#123; <span class="string">&quot;state: <span class="variable">$state</span>&quot;</span> &#125;</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until headers.size) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  state = STATE_OPEN_REQUEST_BODY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出就是负责把<code>Request</code>转化成<code>HTTP</code>标准报文的格式,方便后续发送给服务端。I/O操作用到了<code>OkIo</code>,有兴趣可自行查阅。</p>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transmits a single HTTP request and a response pair. This layers connection management and events</span></span><br><span class="line"><span class="comment"> * on [ExchangeCodec], which handles the actual I/O.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exchange</span></span>(<span class="comment">//...)&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>该类用于传输一对单个<code>Http</code>请求的请求和响应，负责管理连接和ExchangeCodec。同样查看一下<code>Exchange</code>类的<code>writerRequestHeaders</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeRequestHeaders</span><span class="params">(request: <span class="type">Request</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//触发requestHeaders监听开始</span></span><br><span class="line">    eventListener.requestHeadersStart(call)</span><br><span class="line">    <span class="comment">//真正的实现交给ExchangeCodec</span></span><br><span class="line">    codec.writeRequestHeaders(request)</span><br><span class="line">    <span class="comment">//requestHeaders监听结束</span></span><br><span class="line">    eventListener.requestHeadersEnd(call, request)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    eventListener.requestFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，方法内部实际上是把工作交给了<code>ExchangeCodec</code>。<code>Exchange</code>可以看做是对<code>ExchangeCodec</code>的封装，<code>Exchange</code>负责管理连接，<code>ExchangeCodec</code>负责处理具体的编码和解码。</p>
<h3 id="ExchangeFinder"><a href="#ExchangeFinder" class="headerlink" title="ExchangeFinder"></a>ExchangeFinder</h3><p>从<code>ExchangeFinder</code>命名来看，把一次网络请求和响应作为一次数据的<code>exchange</code>(交换)，<code>Finder</code>用来查找一个合适的Exchange，也就是发现一个合适的网络连接。具体是怎么回事先看下<code>ExchangeFinder</code>类的注释说明：<br><img src="/../images/okhttp/ExchangeFinder.png" alt="exchangefinder"><br>尝试查找一个以可用的连接遵循上图红框中的四个策略，大概意思如下:</p>
<ol>
<li>如果当前已经存在一个可以满足请求的连接，则使用它。</li>
<li>如果在连接池中有个可以满足的连接,则使用它。需要注意的是，共享的<code>exchanges</code>可以向不同的主机名发送请求。具体的细节在<code>RealConnection.isEligible</code>这个校验连接合格的方法。</li>
<li>如果没有一个现存的连接，列出所有的路由并尝试建立新连接。如果连接失败，会重试迭代可用的路有列表。</li>
<li>如果一个接连正在尝试DNS解析、TCP连接或TLS握手的时候从池子中获取了一个合格的连接。只有当获取的连接是HTTP2采用<code>multiplexed</code>多路复用，会把重复的连接删除掉。</li>
</ol>
<p>如果现在对注释的内容还不太了解，看了<code>ExchangeFinder</code>的代码后相信一定明白，而且带着注释的看代码，也有助于理解代码为什么这么设计。</p>
<h4 id="ExchangeFinder-find"><a href="#ExchangeFinder-find" class="headerlink" title="ExchangeFinder::find"></a>ExchangeFinder::find</h4><p>官方给这个方法的解释是：Finds a new or pooled connection to carry a forthcoming request and respons————创建一个新的或者从连接池找到一个连接，用来处理即将到来的请求和响应。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  chain: <span class="type">RealInterceptorChain</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ExchangeCodec &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//找到一个健康可用的连接</span></span><br><span class="line">    <span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">        connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">        readTimeout = chain.readTimeoutMillis,</span><br><span class="line">        writeTimeout = chain.writeTimeoutMillis,</span><br><span class="line">        pingIntervalMillis = client.pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = client.retryOnConnectionFailure,</span><br><span class="line">        doExtensiveHealthChecks = chain.request.method != <span class="string">&quot;GET&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//通过获取的连接，创基一个ExchangeCodec</span></span><br><span class="line">    <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">    trackFailure(e.lastConnectException)</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    <span class="keyword">throw</span> RouteException(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法中获取一个健康可用的连接，并通过它创建有个用于编码和解吗的<code>ExchagneCodec</code>,通过之前的分析<code>ExchangeCodec</code>用于连接的管理和I/O的处理，那么其实就可以和服务器通信了。</p>
<h4 id="ExchangeFinder-findHealthyConnection"><a href="#ExchangeFinder-findHealthyConnection" class="headerlink" title="ExchangeFinder::findHealthyConnection"></a>ExchangeFinder::findHealthyConnection</h4><p>上面调用了ExchangeFinder::findHealthyConnection方法，获取了一个健康可用的连接，该方法如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findHealthyConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  doExtensiveHealthChecks: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//获取一个候选的连接</span></span><br><span class="line">    <span class="keyword">val</span> candidate = findConnection(</span><br><span class="line">        connectTimeout = connectTimeout,</span><br><span class="line">        readTimeout = readTimeout,</span><br><span class="line">        writeTimeout = writeTimeout,</span><br><span class="line">        pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the connection is good.</span></span><br><span class="line">    <span class="comment">//检查连接是否健康，该连接是否已准备好</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      <span class="keyword">return</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If it isn&#x27;t, take it out of the pool.</span></span><br><span class="line">    <span class="comment">//如果该连接不健康，则标记该连接不在使用</span></span><br><span class="line">    candidate.noNewExchanges()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we have some routes left to try. One example where we may exhaust all the routes</span></span><br><span class="line">    <span class="comment">// would happen if we made a new connection and it immediately is detected as unhealthy.</span></span><br><span class="line">    <span class="comment">//确保有可尝试的路由</span></span><br><span class="line">    <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> routesLeft = routeSelection?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (routesLeft) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> routesSelectionLeft = routeSelector?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (routesSelectionLeft) <span class="keyword">continue</span></span><br><span class="line">   <span class="comment">//如果没有可用的路由抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> IOException(<span class="string">&quot;exhausted all routes&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该方法的注释可以看出：<strong>该方法会查找到一个可用且健康的连接并将其返回，如果找到的可用连接是不健康的，那么会一直重复查找可用连接的这个过程，直到一个可用且健康的连接被找到</strong>。<br>该方法内部有一个while(true)的循环，在循环代码里面，会不断地去获取一个可用连接，并检查该连接是否健康，如果该连接健康，就将其返回，如果连接不健康，在有可尝试的路由的前提下，会重复前面查找可用连接的过程。注意，这里说的<strong>可用和健康是两个不同的指标</strong>。</p>
<h4 id="RealConnection-isHealthy"><a href="#RealConnection-isHealthy" class="headerlink" title="RealConnection::isHealthy"></a>RealConnection::isHealthy</h4><p>判断连接是否健康的是<code>RealConnection::isHealthy</code>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果此连接已准备好托管新流，则返回true。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isHealthy</span><span class="params">(doExtensiveChecks: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> nowNs = System.nanoTime()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> rawSocket = <span class="keyword">this</span>.rawSocket!!</span><br><span class="line">   <span class="keyword">val</span> socket = <span class="keyword">this</span>.socket!!</span><br><span class="line">   <span class="keyword">val</span> source = <span class="keyword">this</span>.source!!</span><br><span class="line">   <span class="comment">//判断socket是否可用</span></span><br><span class="line">   <span class="keyword">if</span> (rawSocket.isClosed || socket.isClosed || socket.isInputShutdown ||</span><br><span class="line">           socket.isOutputShutdown) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是HTTP2连接，检测HTTP2连接是否健康</span></span><br><span class="line">   <span class="keyword">val</span> http2Connection = <span class="keyword">this</span>.http2Connection</span><br><span class="line">   <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> http2Connection.isHealthy(nowNs)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> idleDurationNs = synchronized(<span class="keyword">this</span>) &#123; nowNs - idleAtNs &#125;</span><br><span class="line">   <span class="comment">//如果空闲时间达到某个值后，检测socket是否健康</span></span><br><span class="line">   <span class="keyword">if</span> (idleDurationNs &gt;= IDLE_CONNECTION_HEALTHY_NS &amp;&amp; doExtensiveChecks) &#123;</span><br><span class="line">     <span class="keyword">return</span> socket.isHealthy(source)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExchangeFinder-findConnection"><a href="#ExchangeFinder-findConnection" class="headerlink" title="ExchangeFinder::findConnection"></a>ExchangeFinder::findConnection</h4><p>在<code>findHealthyConnection</code>方法中调用<code>findConnection</code>方法获取一个候选的连接。该方法代码比较多，逻辑相对比较复杂,也和一开始讲<code>ExchangeFinder</code>类中注释的内容息息相关。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个连接去承载新的流，优先使用现有连接，接着是连接池中的连接，最后是创建一个新的连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">//检测取消call</span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Attempt to reuse the connection from the call.</span></span><br><span class="line">  <span class="comment">//1、尝试去重用call中当前的连接</span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection <span class="comment">// This may be mutated by releaseConnectionNoEvents()!</span></span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="comment">//判断当前存在connection是否符合</span></span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        <span class="comment">//connection不符合释放，则在call中把connection置为空</span></span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="comment">//4、如果connection没有被释放，则返回该当前的连接</span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    <span class="comment">//关闭socket</span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    <span class="comment">//connection被释放的监听</span></span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need a new connection. Give it fresh stats.</span></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">  <span class="comment">//2、 第一次尝试从连接池中获取连接，注意此时的第三个参数routes为空，第三个参数requireMultiplexed为false</span></span><br><span class="line">  <span class="comment">// callAcquirePooledConnection内部判断是个同步方法</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">//返回连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="comment">//如果第一次没从池子中获取到连接，那弄清楚我们接下来要尝试的路由</span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="comment">//第一次进来nextRouteToTry</span></span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// Use a route from an existing route selection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Compute a new route selection. This is a blocking operation!</span></span><br><span class="line">    <span class="comment">//计算一个新的routeSelection，这是一个阻塞的操作</span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="comment">//如果localRouteSelector为则创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从routeSelector中获取一个新的routeSelection</span></span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    <span class="comment">//获取从routeSelector中的route列表</span></span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">    <span class="comment">// the pool. We have a better chance of matching thanks to connection coalescing.</span></span><br><span class="line">    <span class="comment">//3、第二次从连接池中获取连接，此时是routes不为空，也就是有一组IP地址。</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="comment">//返回连接</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果第二次从连接池没拿到，则从routeSelection获取下一个路由，用于创建新的连接。</span></span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect. Tell the call about the connecting call so async cancels work.</span></span><br><span class="line">  <span class="comment">// 4、因为第二次没有从连接池获取到，则创建一个新的连接</span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//执行TCP或TCP+TLS握手。</span></span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we raced another call connecting to this host, coalesce the connections. This makes for 3</span></span><br><span class="line">  <span class="comment">// different lookups in the connection pool!</span></span><br><span class="line">  <span class="comment">//5、第三次从连接池中获取连接。这是因为如果已经创建了一个指向相同主机的连接，并且连接放到连接池里去了。</span></span><br><span class="line">  <span class="comment">//注意此时requireMultiplexed为true，也就是只适用于HTTP2。</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="comment">//获取call当前的connection</span></span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    <span class="comment">//保存路由</span></span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    <span class="comment">//将当前的连接的socket关闭</span></span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果第三次从连接池中没有获取到连接，那这次创建的连接放入到连接池中，然后把创建的连接赋值给call中的connection</span></span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="comment">//返回当前新创建的连接</span></span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取一个可用的连接，分为了5步</p>
<ol>
<li>重用call当中的连接</li>
<li>第一次尝试从连接池获取连接</li>
<li>第二次尝试从连接池获取连接</li>
<li>自己新创建一个连接</li>
<li>第三次尝试从连接池获取连接</li>
</ol>
<p>看到这里先对整个流程做个总结：<br><img src="/./../images/okhttp/image2.png" alt="image2.png"></p>
<h2 id="连接复用"><a href="#连接复用" class="headerlink" title="连接复用"></a>连接复用</h2><h3 id="1-重用call当前的连接"><a href="#1-重用call当前的连接" class="headerlink" title="1.重用call当前的连接"></a>1.重用call当前的连接</h3><p><code>findConnection</code>方法中一大段代码，为了更好的理解我们可以把代码做分段然处理，第一部分如下：<br><img src="/../images/okhttp/%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96Call%E5%BD%93%E5%89%8D%E7%9A%84%E8%BF%9E%E6%8E%A5.png"><br>就是获取一个可用连接的第一步，获取call当前的连接之后，对该连接做了两个判断，分别是</p>
<ul>
<li>判断是否不再接受新的连接</li>
<li>判断和当前请求是否有相同的主机名和端口号</li>
</ul>
<p>回想之前看<code>ExchangeFinder</code>类注释的时候。其中有一条也讲到如果<code>call</code>中有一个满足条件的connection，则重用它：<br><img src="/../images/okhttp/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B3%A8%E9%87%8A.png"><br>这句话所对应的代码就是刚刚讲的部分，可以看出一个优秀的框架，注释都写的很清楚。</p>
<h3 id="代理与路由"><a href="#代理与路由" class="headerlink" title="代理与路由"></a>代理与路由</h3><p>在上面获取连接的时候，为什么要分三次从连接池中获取呢🤔️，每次从连接池获取又有什么不同呢🤔️，要解答这些问题，需要一些http相关的的知识：http中的代理、路由、Http2的多路复用。</p>
<p>代理即代理服务器（Proxy Server），代理服务器是介于客户端和服务器之间的一台服务器，客户端发送给服务器的请求都由代理服务器进行转发，如果没有代理，则客户端直接与服务器进行交互。通过代理服务器，客户端可以隐藏身份，防止受到外来攻击。</p>
<p>在OkHttp中出现两种代理类型：</p>
<ul>
<li>HTTP代理：能够代理客户端进行HTTP访问，主要是代理浏览器访问网页，它的端口号一般为80、8080</li>
<li>SOCKS代理：SOCKS代理与其他类型的代理不同，它只是简单地传递数据包，并不关心是何种应用协议，因此SOCKS代理服务器比其他类型的代理服务器速度要快得多。<br>其中SOCKS4只支持TCP协议，而SOCKS5既支持TCP协议又支持UDP协议。</li>
</ul>
<p>在OkHttp中，对于SOCKS代理，代理服务器完成TCP数据包的转发工作，而HTTP代理，除了转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>在Java中，通过Java.net.Proxy类来描述一个代理服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不使用代理    </span></span><br><span class="line">        DIRECT,</span><br><span class="line">        <span class="comment">// HTTP代理    </span></span><br><span class="line">        HTTP,</span><br><span class="line">        <span class="comment">// SOCKS代理    </span></span><br><span class="line">        SOCKS</span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 代理类型</span></span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line">    <span class="comment">// Socket地址</span></span><br><span class="line">    <span class="keyword">private</span> SocketAddress sa;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类主要包含了代理类型以及代理服务器对应的SocketAddress，其中代理类型有三种：</p>
<ul>
<li>DIRECT：不使用代理</li>
<li>HTTP：使用HTTP代理</li>
<li>SOCKS：使用SOCKS代理</li>
</ul>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>路由在OkHttp中抽象出Route来描述网络数据包的传输路径，最主要还是描述直接与其建立TCP连接的目标端点，它表示一个路由信息</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span></span>(</span><br><span class="line">  <span class="comment">// 记录请求url相关信息，包括请求的源服务器主机名、端口等信息  </span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;address&quot;</span>) <span class="keyword">val</span> address: Address,</span><br><span class="line">  <span class="comment">// 此路由的代理服务器信息  </span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;proxy&quot;</span>) <span class="keyword">val</span> proxy: Proxy,</span><br><span class="line">  <span class="comment">// 连接目标地址  </span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;socketAddress&quot;</span>) <span class="keyword">val</span> socketAddress: InetSocketAddress</span><br><span class="line">) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Route中主要记录了这条路由通过的代理服务器信息Proxy、连接目标地址InetSocketAddress，根据代理协议的不同，这里的InetSocketAddress会有不同的含义：</p>
<ul>
<li>不使用代理：它包含的信息是HTTP服务器经过了DNS解析的IP地址以及协议的端口号。</li>
<li>HTTP代理：它包含的信息是代理服务器经过DNS解析的IP地址以及端口号。</li>
<li>SOCKS代理：它包含的信息是HTTP服务器的域名和协议端口号。</li>
</ul>
<p><code>[https://www.sina.com.cn/](https://www.sina.com.cn/)</code></p>
<ul>
<li><strong>https</strong>: 为协议类型，表面默认端口号443，如果是http默认端口号8080</li>
<li><strong>www</strong>: 是提供服务的机器的名字(计算机名)</li>
<li><strong>sina.com.cn</strong>为域名,域名还分级，从后往前依次降低，cn为顶级域名，表示中国。com是二级域名，表示商业机构。sina是三级域名，一般用自己的名字。</li>
</ul>
<p>主机名：计算机名+域名,及<a target="_blank" rel="noopener" href="http://www.sina.com.cn为主机名/">www.sina.com.cn为主机名</a></p>
<p>一个域名可解析为多个IP地址<br>一个IP地址可以被多个域名绑定</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wds1204.github.io/2022/02/28/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BConnectInterceptor/" data-id="clpp6ms5r001qi1vh1sc421k4" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/okhttp/" rel="tag">okhttp</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2022/03/16/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      CopyOnWriteArrayList源码分析
      
    </div>
  </a>
  
  
  <a href="/2022/02/23/okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BCacheInterceptor/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">okhttp拦截器之CacheInterceptor</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>modi.wu &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank">WU</a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="modi.wu"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>